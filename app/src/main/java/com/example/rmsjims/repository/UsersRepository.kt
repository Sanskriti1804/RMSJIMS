package com.example.rmsjims.repository

import android.util.Log
import com.example.rmsjims.data.schema.Users
import com.example.rmsjims.data.remote.apiservice.UsersApiService
import java.security.MessageDigest

class UsersRepository(
    private val usersApiService: UsersApiService
) {
    private val tag = "UsersRepository"

    /**
     * Authenticate a user by email and password
     * Returns the user if credentials match, null otherwise
     */
    suspend fun authenticateUser(email: String, password: String): Users? {
        Log.d(tag, "Authenticating user: $email")
        
        val user = usersApiService.getUserByEmail(email)
        
        if (user == null) {
            Log.d(tag, "User not found: $email")
            return null
        }
        
        // Compare passwords (in production, use hashed passwords)
        // For now, we'll do plain text comparison since the user wants demo users
        // In production, you should hash passwords and compare hashes
        val passwordMatch = user.password == password
        
        if (passwordMatch) {
            Log.d(tag, "Authentication successful for: $email")
            return user
        } else {
            Log.d(tag, "Invalid password for: $email")
            return null
        }
    }

    suspend fun getUserByEmail(email: String): Users? {
        return usersApiService.getUserByEmail(email)
    }

    suspend fun getAllUsers(): List<Users> {
        return usersApiService.getAllUsers()
    }

    /**
     * Add a new user to the database
     * Validates that email domain matches the role
     */
    suspend fun addUser(email: String, password: String, role: String): Result<Users> {
        Log.d(tag, "Adding user: $email, role: $role")
        
        // Validate email domain matches role
        val expectedDomain = when (role.lowercase()) {
            "admin" -> "@admin.com"
            "staff" -> "@staff.com"
            "assistant" -> "@assistant.com"
            else -> {
                Log.e(tag, "Invalid role: $role")
                return Result.failure(IllegalArgumentException("Invalid role: $role. Must be admin, staff, or assistant"))
            }
        }
        
        val normalizedEmail = email.trim().lowercase()
        if (!normalizedEmail.endsWith(expectedDomain)) {
            Log.e(tag, "Email domain mismatch: $normalizedEmail does not end with $expectedDomain")
            return Result.failure(IllegalArgumentException("Email must end with $expectedDomain for $role role"))
        }
        
        // Check if user already exists
        val existingUser = usersApiService.getUserByEmail(normalizedEmail)
        if (existingUser != null) {
            Log.e(tag, "User already exists: $normalizedEmail")
            return Result.failure(IllegalArgumentException("User with email $normalizedEmail already exists"))
        }
        
        return try {
            val newUser = Users(
                id = null, // Will be auto-generated by database
                email = normalizedEmail,
                password = password,
                role = role.lowercase()
            )
            val createdUser = usersApiService.addUser(newUser)
            Log.d(tag, "User added successfully: ${createdUser.email}")
            Result.success(createdUser)
        } catch (e: Exception) {
            Log.e(tag, "Error adding user", e)
            Result.failure(e)
        }
    }
}

